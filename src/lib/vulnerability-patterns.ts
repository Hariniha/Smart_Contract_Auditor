// Vulnerability Detection Patterns

import { VulnerabilityPattern } from '@/types';

export const VULNERABILITY_PATTERNS: VulnerabilityPattern[] = [
  // Reentrancy (SWC-107)
  {
    pattern: /\.call\{value:\s*\w+\}|\.call\.value\(|\.send\(|\.transfer\(/,
    swcId: 'SWC-107',
    name: 'Potential Reentrancy',
    severity: 'Critical',
    description: 'External call detected that may be vulnerable to reentrancy attacks',
    scsvIds: ['V6.1', 'V6.4'],
    check: (code: string) => {
      // Only flag if state changes AFTER external call (CEI violation)
      const lines = code.split('\n');
      for (let i = 0; i < lines.length; i++) {
        if (/\.call\{value:|\.send\(|msg\.sender\.transfer\(/.test(lines[i])) {
          // Check next 5 lines for state changes AFTER the call
          for (let j = i + 1; j < Math.min(i + 6, lines.length); j++) {
            // State changes: assignments, balance updates, array modifications
            if (/\w+\[.*\]\s*=|balances\[|\w+\s*=\s*(?!address\(|bool\()|\.(push|pop)\(/.test(lines[j])) {
              return true; // Vulnerable: state change after external call
            }
            if (lines[j].includes('}')) break; // End of function
          }
        }
      }
      return false; // Safe: follows CEI pattern
    }
  },

  // Unprotected Ether Withdrawal (SWC-105)
  {
    pattern: /function\s+withdraw.*public|function\s+withdrawAll.*public/i,
    swcId: 'SWC-105',
    name: 'Unprotected Ether Withdrawal',
    severity: 'Critical',
    description: 'Withdrawal function may lack proper access controls',
    scsvIds: ['V2.1', 'V2.2', 'V9.2'],
    check: (code: string) => {
      const lines = code.split('\n');
      let inWithdrawFunction = false;
      let hasProtection = false;
      let isUserWithdrawal = false;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        
        // Detect withdrawal function start
        if (/function\s+\w*withdraw\w*/i.test(line)) {
          inWithdrawFunction = true;
          // External/internal visibility is protective
          if (/external|internal/.test(line)) hasProtection = true;
        }
        
        if (inWithdrawFunction) {
          // Check for access control patterns
          if (/onlyOwner|onlyAdmin|require\(.*msg\.sender\s*==/.test(line)) {
            hasProtection = true;
          }
          // User accessing their own balance is safe (not privileged withdrawal)
          if (/balances\[msg\.sender\]|userBalance|balance\[msg\.sender/.test(line)) {
            isUserWithdrawal = true;
          }
          // End of function
          if (line.includes('}') && inWithdrawFunction) {
            // Only flag if no protection AND not user-only withdrawal
            if (!hasProtection && !isUserWithdrawal) return true;
            // Reset for next function
            inWithdrawFunction = false;
            hasProtection = false;
            isUserWithdrawal = false;
          }
        }
      }
      return false;
    }
  },

  // Unprotected SELFDESTRUCT (SWC-106)
  {
    pattern: /selfdestruct\(/i,
    swcId: 'SWC-106',
    name: 'Unprotected SELFDESTRUCT',
    severity: 'Critical',
    description: 'selfdestruct instruction may be callable by anyone',
    scsvIds: ['V2.1', 'V2.3', 'V9.2'],
    check: (code: string) => {
      const hasSelfDestruct = /selfdestruct\(/i.test(code);
      const hasProtection = /onlyOwner|require\(.*msg\.sender/.test(code);
      return hasSelfDestruct && !hasProtection;
    }
  },

  // Delegatecall to Untrusted Callee (SWC-112)
  {
    pattern: /\.delegatecall\(/i,
    swcId: 'SWC-112',
    name: 'Delegatecall to Untrusted Callee',
    severity: 'Critical',
    description: 'delegatecall usage may allow arbitrary code execution',
    scsvIds: ['V6.3', 'V4.1', 'V2.1'],
    check: (code: string) => /\.delegatecall\(/i.test(code)
  },

  // Integer Overflow/Underflow (SWC-101)
  {
    pattern: /\+\+|--|\+=|-=|\*=|\/=/,
    swcId: 'SWC-101',
    name: 'Potential Integer Overflow/Underflow',
    severity: 'Critical',
    description: 'Arithmetic operation without overflow protection detected',
    scsvIds: ['V3.1', 'V3.3'],
    check: (code: string) => {
      // Check Solidity version - 0.8.0+ has built-in overflow protection
      const versionMatch = code.match(/pragma\s+solidity\s+[\^]?([0-9]+)\.([0-9]+)/);
      if (versionMatch) {
        const major = parseInt(versionMatch[1]);
        const minor = parseInt(versionMatch[2]);
        // Solidity 0.8.0 and above has built-in overflow protection
        if (major > 0 || (major === 0 && minor >= 8)) {
          return false; // Safe in 0.8.0+
        }
      }
      
      // For older versions, check if SafeMath is used
      const hasArithmetic = /\+\+|--|\+=|-=|\*=/.test(code);
      const hasSafeMath = /SafeMath|using\s+SafeMath/.test(code);
      return hasArithmetic && !hasSafeMath;
    }
  },

  // Unchecked Call Return Value (SWC-104)
  {
    pattern: /\.call\(|\.delegatecall\(|\.send\(/,
    swcId: 'SWC-104',
    name: 'Unchecked Call Return Value',
    severity: 'High',
    description: 'Return value of external call is not checked',
    scsvIds: ['V6.2', 'V4.1'],
    check: (code: string) => {
      const lines = code.split('\n');
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (/\.call\{|\.call\(|\.send\(/.test(line)) {
          // Check if return value is captured: (bool success, ) or bool success =
          const hasCapture = /\(bool\s+\w+|bool\s+\w+\s*=/.test(line);
          // Check same line or next line for require/if statement
          const nextLine = lines[i + 1] || '';
          const hasCheck = /require\(|if\s*\(/.test(line) || /require\(|if\s*\(/.test(nextLine);
          // Transfer is safe (reverts on failure)
          const isTransfer = /\.transfer\(/.test(line);
          
          if (!hasCapture && !hasCheck && !isTransfer) {
            return true; // Vulnerable: return value not checked
          }
        }
      }
      return false;
    }
  },

  // tx.origin Authentication (SWC-115)
  {
    pattern: /tx\.origin/,
    swcId: 'SWC-115',
    name: 'Authorization through tx.origin',
    severity: 'High',
    description: 'tx.origin used for authorization is vulnerable to phishing attacks',
    scsvIds: ['V2.4', 'V2.1'],
    check: (code: string) => /tx\.origin/.test(code)
  },

  // Block Timestamp Manipulation (SWC-116)
  {
    pattern: /block\.timestamp|now\s/,
    swcId: 'SWC-116',
    name: 'Block Timestamp Dependency',
    severity: 'Medium',
    description: 'Use of block.timestamp can be influenced by miners',
    scsvIds: ['V10.1', 'V9.3'],
    check: (code: string) => {
      // Only flag if timestamp is used in critical logic (require, if conditions)
      // Not just for logging or non-critical tracking
      const lines = code.split('\n');
      for (const line of lines) {
        if (/block\.timestamp|now\s/.test(line)) {
          // Critical usage: in require statements or conditional logic
          if (/require\(.*block\.timestamp|if\s*\(.*block\.timestamp|require\(.*now\s|if\s*\(.*now\s/.test(line)) {
            return true;
          }
        }
      }
      return false;
    }
  },

  // Weak Randomness (SWC-120)
  {
    pattern: /block\.timestamp|block\.difficulty|block\.number.*random|blockhash/i,
    swcId: 'SWC-120',
    name: 'Weak Source of Randomness',
    severity: 'High',
    description: 'Randomness source can be predicted or manipulated',
    scsvIds: ['V10.2', 'V10.3'],
    check: (code: string) => {
      const hasRandom = /random/i.test(code);
      const usesBlockData = /block\.(timestamp|difficulty|number|blockhash)/.test(code);
      return hasRandom && usesBlockData;
    }
  },

  // Function Default Visibility (SWC-100)
  {
    pattern: /function\s+\w+\s*\([^)]*\)\s*(?!public|private|internal|external)/,
    swcId: 'SWC-100',
    name: 'Function Default Visibility',
    severity: 'High',
    description: 'Function visibility not explicitly declared',
    scsvIds: ['V2.1', 'V13.1', 'V13.2'],
    check: (code: string) => {
      // Match function declarations including multi-line with modifiers
      const lines = code.split('\n');
      for (let i = 0; i < lines.length; i++) {
        if (/function\s+\w+/.test(lines[i])) {
          // Check current line and next 3 lines for visibility keyword
          const chunk = lines.slice(i, Math.min(i + 4, lines.length)).join(' ');
          if (!/\b(public|private|internal|external)\b/.test(chunk)) {
            // Ignore constructor, fallback, receive (they have implicit visibility)
            if (!/constructor|fallback|receive/.test(chunk)) {
              return true;
            }
          }
        }
      }
      return false;
    }
  },

  // State Variable Default Visibility (SWC-108)
  {
    pattern: /^\s*(uint|int|bool|address|string|bytes|mapping)\s+/m,
    swcId: 'SWC-108',
    name: 'State Variable Default Visibility',
    severity: 'Medium',
    description: 'State variable visibility not explicitly declared',
    scsvIds: ['V8.1', 'V8.2', 'V13.1'],
    check: (code: string) => {
      const lines = code.split('\n');
      let insideFunction = false;
      let bracketCount = 0;
      let inContractBody = false;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Track contract body
        if (/contract\s+\w+/.test(line)) {
          inContractBody = true;
          continue;
        }
        
        if (!inContractBody) continue;
        
        // Track if we're inside a function/modifier/constructor
        if (/function\s+|modifier\s+|constructor\s*\(/.test(line)) {
          insideFunction = true;
        }
        
        // Count braces to track scope
        bracketCount += (line.match(/\{/g) || []).length;
        bracketCount -= (line.match(/\}/g) || []).length;
        
        // Reset when exiting function scope
        if (insideFunction && bracketCount === 1 && line.includes('}')) {
          insideFunction = false;
        }
        
        // Skip if inside function, comment, or special declarations
        if (insideFunction || line.startsWith('//') || line.startsWith('/*') || 
            line.startsWith('*') || line.includes('event ') || line.length === 0) {
          continue;
        }
        
        // Match state variable declarations at contract level only
        const stateVarPattern = /^\s*(uint\d*|int\d*|bool|address|string|bytes\d*|mapping)\s+\w/;
        if (stateVarPattern.test(line)) {
          // Check if visibility keyword is present
          if (!/\b(public|private|internal|constant|immutable)\b/.test(line)) {
            // Make sure it's a complete declaration (has ; or =)
            if (/[;=]/.test(line)) {
              return true;
            }
          }
        }
      }
      return false;
    }
  },

  // Floating Pragma (SWC-103) - Informational only
  {
    pattern: /pragma\s+solidity\s+\^/,
    swcId: 'SWC-103',
    name: 'Floating Pragma',
    severity: 'Low',
    description: 'Floating pragma allows compilation with multiple versions (best practice: use fixed version)',
    scsvIds: ['V15.1', 'V13.3'],
    check: (code: string) => {
      // Only flag if using very old or insecure version ranges
      if (/pragma\s+solidity\s+\^0\.[0-6]/.test(code)) return true;
      return false; // ^0.8.0 is generally acceptable
    }
  },

  // Outdated Compiler Version (SWC-102)
  {
    pattern: /pragma\s+solidity/,
    swcId: 'SWC-102',
    name: 'Outdated Compiler Version',
    severity: 'Medium',
    description: 'Consider using a more recent compiler version',
    scsvIds: ['V15.1', 'V15.3'],
    check: (code: string) => {
      const match = code.match(/pragma\s+solidity\s+.*?([0-9]+)\.([0-9]+)\.([0-9]+)/);
      if (!match) return false;
      const major = parseInt(match[1]);
      const minor = parseInt(match[2]);
      return major === 0 && minor < 8;
    }
  },

  // Uninitialized Storage Pointer (SWC-109)
  {
    pattern: /^\s*\w+\[\]\s+\w+\s*;/m,
    swcId: 'SWC-109',
    name: 'Uninitialized Storage Pointer',
    severity: 'High',
    description: 'Uninitialized storage variable detected',
    scsvIds: ['V9.1', 'V4.1'],
    check: (code: string) => {
      return /^\s*\w+\[\]\s+\w+\s*;/m.test(code);
    }
  },

  // DoS with Block Gas Limit (SWC-128)
  {
    pattern: /for\s*\([^)]*\)\s*\{[^}]*\.push\(/,
    swcId: 'SWC-128',
    name: 'DoS with Block Gas Limit',
    severity: 'High',
    description: 'Unbounded loop that modifies storage may hit gas limit',
    scsvIds: ['V5.1', 'V5.3', 'V6.4'],
    check: (code: string) => {
      const lines = code.split('\n');
      for (let i = 0; i < lines.length; i++) {
        if (/for\s*\(/.test(lines[i])) {
          // Check if loop is bounded (has fixed length or small limit)
          const forLine = lines[i];
          if (/\.length|<\s*\d+/.test(forLine)) {
            // Check next 10 lines for storage operations
            const loopBody = lines.slice(i, Math.min(i + 10, lines.length)).join('\n');
            // Only flag if loop modifies storage in unbounded way
            if (/\.push\(.*\)/.test(loopBody) && !/\.length\s*<\s*\d{1,2}/.test(forLine)) {
              return true; // Potentially unbounded
            }
          }
        }
      }
      return false;
    }
  },

  // Transaction Order Dependence (SWC-114)
  {
    pattern: /approve\s*\(/,
    swcId: 'SWC-114',
    name: 'Transaction Order Dependence',
    severity: 'High',
    description: 'Function may be vulnerable to front-running attacks',
    scsvIds: ['V12.3', 'V9.2'],
    check: (code: string) => /function\s+approve\s*\(/.test(code)
  },

  // Deprecated Functions (SWC-111)
  {
    pattern: /suicide\(|throw\b|sha3\(|block\.blockhash/,
    swcId: 'SWC-111',
    name: 'Use of Deprecated Functions',
    severity: 'Low',
    description: 'Deprecated Solidity functions should not be used',
    scsvIds: ['V15.2', 'V13.2'],
    check: (code: string) => /suicide\(|throw\b|sha3\(|block\.blockhash/.test(code)
  },

  // Signature Malleability (SWC-117)
  {
    pattern: /ecrecover\(/,
    swcId: 'SWC-117',
    name: 'Signature Malleability',
    severity: 'Low',
    description: 'ecrecover may be vulnerable to signature malleability (ensure v parameter validation)',
    scsvIds: ['V11.1', 'V11.3'],
    check: (code: string) => {
      // Only flag if no v parameter validation
      const hasEcrecover = /ecrecover\(/.test(code);
      const hasVCheck = /require\(.*v\s*==|if\s*\(.*v\s*==/.test(code);
      return hasEcrecover && !hasVCheck;
    }
  },

  // Missing Replay Protection (SWC-121)
  {
    pattern: /ecrecover\(/,
    swcId: 'SWC-121',
    name: 'Missing Signature Replay Protection',
    severity: 'High',
    description: 'Signature verification may lack replay protection',
    scsvIds: ['V11.2', 'V11.1'],
    check: (code: string) => {
      const hasEcrecover = /ecrecover\(/.test(code);
      const hasNonce = /nonce/.test(code);
      return hasEcrecover && !hasNonce;
    }
  },

  // Hash Collision (SWC-133)
  {
    pattern: /abi\.encodePacked\(/,
    swcId: 'SWC-133',
    name: 'Hash Collision with Variable Length Arguments',
    severity: 'High',
    description: 'abi.encodePacked with multiple variable length arguments may cause collisions',
    scsvIds: ['V11.3', 'V4.1'],
    check: (code: string) => /abi\.encodePacked\(.*,.*\[/.test(code)
  },

  // Message Call with Hardcoded Gas (SWC-134)
  {
    pattern: /\.call\{gas:\s*\d+\}/,
    swcId: 'SWC-134',
    name: 'Message Call with Hardcoded Gas',
    severity: 'Medium',
    description: 'Hardcoded gas amount may cause issues in future hard forks',
    scsvIds: ['V5.2', 'V6.2'],
    check: (code: string) => /\.call\{gas:\s*\d+\}/.test(code)
  },

  // Unencrypted Private Data (SWC-136)
  {
    pattern: /private\s+(uint|int|address|string|bytes).*password|private.*secret|private.*key/i,
    swcId: 'SWC-136',
    name: 'Unencrypted Private Data On-Chain',
    severity: 'High',
    description: 'Private variables are visible on blockchain',
    scsvIds: ['V8.1', 'V8.2'],
    check: (code: string) => /private\s+.*?(password|secret|key|private)/i.test(code)
  }
];

export function getPatternBySWC(swcId: string): VulnerabilityPattern | undefined {
  return VULNERABILITY_PATTERNS.find(p => p.swcId === swcId);
}

export function getPatternsBySeverity(severity: string): VulnerabilityPattern[] {
  return VULNERABILITY_PATTERNS.filter(p => p.severity === severity);
}
